{"ast":null,"code":"export const transformToBackendPayload = (nodes, edges) => {\n  const network_elements = nodes.filter(n => n.type === 'ne').map(neNode => ({\n    ...neNode.data,\n    cards: nodes.filter(c => c.type === 'card' && c.parentNode === neNode.id).map(cardNode => ({\n      ...cardNode.data,\n      ports: nodes.filter(p => p.type === 'port' && p.parentNode === cardNode.id).map(portNode => {\n        const port_no = parseInt(portNode.data.port_no, 10);\n        return {\n          ...portNode.data,\n          port_no: isNaN(port_no) ? 0 : port_no\n        };\n      })\n    }))\n  }));\n  const connections = edges.map(edge => {\n    var _edge$data, _edge$data$is_bidirec, _edge$data2, _edge$data3;\n    const sourcePortNode = nodes.find(n => n.id === edge.source);\n    const targetPortNode = nodes.find(n => n.id === edge.target);\n    if (!sourcePortNode || !targetPortNode) return null;\n    const sourceCardNode = nodes.find(n => n.id === sourcePortNode.parentNode);\n    const targetCardNode = nodes.find(n => n.id === targetPortNode.parentNode);\n    if (!sourceCardNode || !targetCardNode) return null;\n    const sourceNeNode = nodes.find(n => n.id === sourceCardNode.parentNode);\n    const targetNeNode = nodes.find(n => n.id === targetCardNode.parentNode);\n    if (!sourceNeNode || !targetNeNode) return null;\n    return {\n      id: edge.id,\n      source: {\n        ne: sourceNeNode.id,\n        card: sourceCardNode.id,\n        port: sourcePortNode.id\n      },\n      destination: {\n        ne: targetNeNode.id,\n        card: targetCardNode.id,\n        port: targetPortNode.id\n      },\n      is_internal: ((_edge$data = edge.data) === null || _edge$data === void 0 ? void 0 : _edge$data.is_internal) || false,\n      is_bidirectional: (_edge$data$is_bidirec = (_edge$data2 = edge.data) === null || _edge$data2 === void 0 ? void 0 : _edge$data2.is_bidirectional) !== null && _edge$data$is_bidirec !== void 0 ? _edge$data$is_bidirec : true,\n      is_dd: ((_edge$data3 = edge.data) === null || _edge$data3 === void 0 ? void 0 : _edge$data3.is_dd) || false\n    };\n  }).filter(c => c !== null);\n  return {\n    network_elements,\n    connections\n  };\n};\nexport const generateConfiguration = async (nodes, edges) => {\n  const payload = transformToBackendPayload(nodes, edges);\n  try {\n    const response = await fetch('/api/generate-config', {\n      // Assuming the backend is on the same host\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(payload)\n    });\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const result = await response.json();\n    console.log('Configuration generated successfully:', result);\n    return result.config;\n  } catch (error) {\n    console.error('Failed to generate configuration:', error);\n    alert(`Failed to generate configuration: ${error.message}`);\n    return null;\n  }\n};","map":{"version":3,"names":["transformToBackendPayload","nodes","edges","network_elements","filter","n","type","map","neNode","data","cards","c","parentNode","id","cardNode","ports","p","portNode","port_no","parseInt","isNaN","connections","edge","_edge$data","_edge$data$is_bidirec","_edge$data2","_edge$data3","sourcePortNode","find","source","targetPortNode","target","sourceCardNode","targetCardNode","sourceNeNode","targetNeNode","ne","card","port","destination","is_internal","is_bidirectional","is_dd","generateConfiguration","payload","response","fetch","method","headers","body","JSON","stringify","ok","Error","status","result","json","console","log","config","error","alert","message"],"sources":["C:/Users/yagrawal/OneDrive - Ribbon Communications Operating Company, Inc/Desktop/config_tool/frontend/src/api.js"],"sourcesContent":["export const transformToBackendPayload = (nodes, edges) => {\n    const network_elements = nodes\n        .filter(n => n.type === 'ne')\n        .map(neNode => ({\n            ...neNode.data,\n            cards: nodes\n                .filter(c => c.type === 'card' && c.parentNode === neNode.id)\n                .map(cardNode => ({\n                    ...cardNode.data,\n                    ports: nodes\n                        .filter(p => p.type === 'port' && p.parentNode === cardNode.id)\n                        .map(portNode => {\n                            const port_no = parseInt(portNode.data.port_no, 10);\n                            return {...portNode.data, port_no: isNaN(port_no) ? 0 : port_no};\n                        })\n                }))\n        }));\n\n    const connections = edges.map(edge => {\n        const sourcePortNode = nodes.find(n => n.id === edge.source);\n        const targetPortNode = nodes.find(n => n.id === edge.target);\n\n        if (!sourcePortNode || !targetPortNode) return null;\n\n        const sourceCardNode = nodes.find(n => n.id === sourcePortNode.parentNode);\n        const targetCardNode = nodes.find(n => n.id === targetPortNode.parentNode);\n\n        if (!sourceCardNode || !targetCardNode) return null;\n\n        const sourceNeNode = nodes.find(n => n.id === sourceCardNode.parentNode);\n        const targetNeNode = nodes.find(n => n.id === targetCardNode.parentNode);\n\n        if (!sourceNeNode || !targetNeNode) return null;\n\n        return {\n            id: edge.id,\n            source: {\n                ne: sourceNeNode.id,\n                card: sourceCardNode.id,\n                port: sourcePortNode.id\n            },\n            destination: {\n                ne: targetNeNode.id,\n                card: targetCardNode.id,\n                port: targetPortNode.id\n            },\n            is_internal: edge.data?.is_internal || false,\n            is_bidirectional: edge.data?.is_bidirectional ?? true,\n            is_dd: edge.data?.is_dd || false,\n        };\n    }).filter(c => c !== null);\n\n    return { network_elements, connections };\n};\n\nexport const generateConfiguration = async (nodes, edges) => {\n    const payload = transformToBackendPayload(nodes, edges);\n\n    try {\n        const response = await fetch('/api/generate-config', { // Assuming the backend is on the same host\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(payload),\n        });\n\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n\n        const result = await response.json();\n        console.log('Configuration generated successfully:', result);\n        return result.config;\n    } catch (error) {\n        console.error('Failed to generate configuration:', error);\n        alert(`Failed to generate configuration: ${error.message}`);\n        return null;\n    }\n};\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}