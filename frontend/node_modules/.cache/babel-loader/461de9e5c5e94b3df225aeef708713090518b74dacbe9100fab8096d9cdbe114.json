{"ast":null,"code":"export const transformToBackendPayload = (nodes, edges) => {\n  const network_elements = nodes.filter(n => n.type === 'ne').map(neNode => ({\n    ...neNode.data,\n    cards: nodes.filter(c => c.type === 'card' && c.parentNode === neNode.id).map(cardNode => ({\n      ...cardNode.data,\n      ports: nodes.filter(p => p.type === 'port' && p.parentNode === cardNode.id).map(portNode => ({\n        ...portNode.data,\n        port_no: parseInt(portNode.data.port_no, 10)\n      }))\n    }))\n  }));\n  const connections = edges.map(edge => {\n    var _edge$data, _edge$data2;\n    const sourceNE = nodes.find(n => n.id === edge.source);\n    const targetNE = nodes.find(n => n.id === edge.target);\n    if (!sourceNE || !targetNE) return null;\n    let sourceCardId = null;\n    let targetCardId = null;\n\n    // Find the source card\n    const sourceNeElement = network_elements.find(ne => ne.id === edge.source);\n    if (sourceNeElement) {\n      for (const card of sourceNeElement.cards) {\n        if (card.ports.some(p => p.id === edge.sourceHandle)) {\n          sourceCardId = card.id;\n          break;\n        }\n      }\n    }\n\n    // Find the target card\n    const targetNeElement = network_elements.find(ne => ne.id === edge.target);\n    if (targetNeElement) {\n      for (const card of targetNeElement.cards) {\n        if (card.ports.some(p => p.id === edge.targetHandle)) {\n          targetCardId = card.id;\n          break;\n        }\n      }\n    }\n    if (!sourceCardId || !targetCardId) return null;\n    return {\n      id: edge.id,\n      source: {\n        ne: edge.source,\n        card: sourceCardId,\n        port: edge.sourceHandle\n      },\n      destination: {\n        ne: edge.target,\n        card: targetCardId,\n        port: edge.targetHandle\n      },\n      is_internal: ((_edge$data = edge.data) === null || _edge$data === void 0 ? void 0 : _edge$data.is_internal) || false,\n      is_bidirectional: ((_edge$data2 = edge.data) === null || _edge$data2 === void 0 ? void 0 : _edge$data2.is_bidirectional) || true\n    };\n  }).filter(c => c !== null);\n  return {\n    network_elements,\n    connections\n  };\n};\nexport const generateConfiguration = async (nodes, edges) => {\n  const payload = transformToBackendPayload(nodes, edges);\n  try {\n    const response = await fetch('/api/generate-config', {\n      // Assuming the backend is on the same host\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(payload)\n    });\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const result = await response.json();\n    console.log('Configuration generated successfully:', result);\n    return result.config;\n  } catch (error) {\n    console.error('Failed to generate configuration:', error);\n    alert(`Failed to generate configuration: ${error.message}`);\n    return null;\n  }\n};","map":{"version":3,"names":["transformToBackendPayload","nodes","edges","network_elements","filter","n","type","map","neNode","data","cards","c","parentNode","id","cardNode","ports","p","portNode","port_no","parseInt","connections","edge","_edge$data","_edge$data2","sourceNE","find","source","targetNE","target","sourceCardId","targetCardId","sourceNeElement","ne","card","some","sourceHandle","targetNeElement","targetHandle","port","destination","is_internal","is_bidirectional","generateConfiguration","payload","response","fetch","method","headers","body","JSON","stringify","ok","Error","status","result","json","console","log","config","error","alert","message"],"sources":["C:/Users/yagrawal/OneDrive - Ribbon Communications Operating Company, Inc/Desktop/config_tool/frontend/src/api.js"],"sourcesContent":["export const transformToBackendPayload = (nodes, edges) => {\n    const network_elements = nodes\n        .filter(n => n.type === 'ne')\n        .map(neNode => ({\n            ...neNode.data,\n            cards: nodes\n                .filter(c => c.type === 'card' && c.parentNode === neNode.id)\n                .map(cardNode => ({\n                    ...cardNode.data,\n                    ports: nodes\n                        .filter(p => p.type === 'port' && p.parentNode === cardNode.id)\n                        .map(portNode => ({...portNode.data, port_no: parseInt(portNode.data.port_no, 10)}))\n                }))\n        }));\n\n    const connections = edges.map(edge => {\n        const sourceNE = nodes.find(n => n.id === edge.source);\n        const targetNE = nodes.find(n => n.id === edge.target);\n\n        if (!sourceNE || !targetNE) return null;\n\n        let sourceCardId = null;\n        let targetCardId = null;\n\n        // Find the source card\n        const sourceNeElement = network_elements.find(ne => ne.id === edge.source);\n        if (sourceNeElement) {\n            for (const card of sourceNeElement.cards) {\n                if (card.ports.some(p => p.id === edge.sourceHandle)) {\n                    sourceCardId = card.id;\n                    break;\n                }\n            }\n        }\n\n        // Find the target card\n        const targetNeElement = network_elements.find(ne => ne.id === edge.target);\n        if (targetNeElement) {\n            for (const card of targetNeElement.cards) {\n                if (card.ports.some(p => p.id === edge.targetHandle)) {\n                    targetCardId = card.id;\n                    break;\n                }\n            }\n        }\n\n        if (!sourceCardId || !targetCardId) return null;\n\n        return {\n            id: edge.id,\n            source: {\n                ne: edge.source,\n                card: sourceCardId,\n                port: edge.sourceHandle\n            },\n            destination: {\n                ne: edge.target,\n                card: targetCardId,\n                port: edge.targetHandle\n            },\n            is_internal: edge.data?.is_internal || false,\n            is_bidirectional: edge.data?.is_bidirectional || true,\n        };\n    }).filter(c => c !== null);\n\n    return { network_elements, connections };\n};\n\nexport const generateConfiguration = async (nodes, edges) => {\n    const payload = transformToBackendPayload(nodes, edges);\n\n    try {\n        const response = await fetch('/api/generate-config', { // Assuming the backend is on the same host\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(payload),\n        });\n\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n\n        const result = await response.json();\n        console.log('Configuration generated successfully:', result);\n        return result.config;\n    } catch (error) {\n        console.error('Failed to generate configuration:', error);\n        alert(`Failed to generate configuration: ${error.message}`);\n        return null;\n    }\n};\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}