{"ast":null,"code":"export const transformToBackendPayload = (nodes, edges) => {\n  const network_elements = nodes.filter(n => n.type === 'ne').map(neNode => ({\n    ...neNode.data,\n    cards: nodes.filter(c => c.type === 'card' && c.parentNode === neNode.id).map(cardNode => ({\n      ...cardNode.data,\n      ports: nodes.filter(p => p.type === 'port' && p.parentNode === cardNode.id).map(portNode => ({\n        ...portNode.data,\n        port_no: parseInt(portNode.data.port_no, 10)\n      }))\n    }))\n  }));\n  const connections = edges.map(edge => {\n    var _edge$data, _edge$data$is_bidirec, _edge$data2, _edge$data3;\n    const sourcePortNode = nodes.find(n => n.id === edge.source);\n    const targetPortNode = nodes.find(n => n.id === edge.target);\n    if (!sourcePortNode || !targetPortNode) return null;\n    const sourceCardNode = nodes.find(n => n.id === sourcePortNode.parentNode);\n    const targetCardNode = nodes.find(n => n.id === targetPortNode.parentNode);\n    if (!sourceCardNode || !targetCardNode) return null;\n    const sourceNeNode = nodes.find(n => n.id === sourceCardNode.parentNode);\n    const targetNeNode = nodes.find(n => n.id === targetCardNode.parentNode);\n    if (!sourceNeNode || !targetNeNode) return null;\n    return {\n      id: edge.id,\n      source: {\n        ne: sourceNeNode.id,\n        card: sourceCardNode.id,\n        port: sourcePortNode.id\n      },\n      destination: {\n        ne: targetNeNode.id,\n        card: targetCardNode.id,\n        port: targetPortNode.id\n      },\n      is_internal: ((_edge$data = edge.data) === null || _edge$data === void 0 ? void 0 : _edge$data.is_internal) || false,\n      is_bidirectional: (_edge$data$is_bidirec = (_edge$data2 = edge.data) === null || _edge$data2 === void 0 ? void 0 : _edge$data2.is_bidirectional) !== null && _edge$data$is_bidirec !== void 0 ? _edge$data$is_bidirec : true,\n      is_dd: ((_edge$data3 = edge.data) === null || _edge$data3 === void 0 ? void 0 : _edge$data3.is_dd) || false\n    };\n  }).filter(c => c !== null);\n  return {\n    network_elements,\n    connections\n  };\n};\nexport const generateConfiguration = async (nodes, edges) => {\n  const payload = transformToBackendPayload(nodes, edges);\n  try {\n    const response = await fetch('/api/generate-config', {\n      // Assuming the backend is on the same host\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(payload)\n    });\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const result = await response.json();\n    console.log('Configuration generated successfully:', result);\n    return result.config;\n  } catch (error) {\n    console.error('Failed to generate configuration:', error);\n    alert(`Failed to generate configuration: ${error.message}`);\n    return null;\n  }\n};","map":{"version":3,"names":["transformToBackendPayload","nodes","edges","network_elements","filter","n","type","map","neNode","data","cards","c","parentNode","id","cardNode","ports","p","portNode","port_no","parseInt","connections","edge","_edge$data","_edge$data$is_bidirec","_edge$data2","_edge$data3","sourcePortNode","find","source","targetPortNode","target","sourceCardNode","targetCardNode","sourceNeNode","targetNeNode","ne","card","port","destination","is_internal","is_bidirectional","is_dd","generateConfiguration","payload","response","fetch","method","headers","body","JSON","stringify","ok","Error","status","result","json","console","log","config","error","alert","message"],"sources":["C:/Users/yagrawal/OneDrive - Ribbon Communications Operating Company, Inc/Desktop/config_tool/frontend/src/api.js"],"sourcesContent":["export const transformToBackendPayload = (nodes, edges) => {\n    const network_elements = nodes\n        .filter(n => n.type === 'ne')\n        .map(neNode => ({\n            ...neNode.data,\n            cards: nodes\n                .filter(c => c.type === 'card' && c.parentNode === neNode.id)\n                .map(cardNode => ({\n                    ...cardNode.data,\n                    ports: nodes\n                        .filter(p => p.type === 'port' && p.parentNode === cardNode.id)\n                        .map(portNode => ({...portNode.data, port_no: parseInt(portNode.data.port_no, 10)}))\n                }))\n        }));\n\n    const connections = edges.map(edge => {\n        const sourcePortNode = nodes.find(n => n.id === edge.source);\n        const targetPortNode = nodes.find(n => n.id === edge.target);\n\n        if (!sourcePortNode || !targetPortNode) return null;\n\n        const sourceCardNode = nodes.find(n => n.id === sourcePortNode.parentNode);\n        const targetCardNode = nodes.find(n => n.id === targetPortNode.parentNode);\n\n        if (!sourceCardNode || !targetCardNode) return null;\n\n        const sourceNeNode = nodes.find(n => n.id === sourceCardNode.parentNode);\n        const targetNeNode = nodes.find(n => n.id === targetCardNode.parentNode);\n\n        if (!sourceNeNode || !targetNeNode) return null;\n\n        return {\n            id: edge.id,\n            source: {\n                ne: sourceNeNode.id,\n                card: sourceCardNode.id,\n                port: sourcePortNode.id\n            },\n            destination: {\n                ne: targetNeNode.id,\n                card: targetCardNode.id,\n                port: targetPortNode.id\n            },\n            is_internal: edge.data?.is_internal || false,\n            is_bidirectional: edge.data?.is_bidirectional ?? true,\n            is_dd: edge.data?.is_dd || false,\n        };\n    }).filter(c => c !== null);\n\n    return { network_elements, connections };\n};\n\nexport const generateConfiguration = async (nodes, edges) => {\n    const payload = transformToBackendPayload(nodes, edges);\n\n    try {\n        const response = await fetch('/api/generate-config', { // Assuming the backend is on the same host\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(payload),\n        });\n\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n\n        const result = await response.json();\n        console.log('Configuration generated successfully:', result);\n        return result.config;\n    } catch (error) {\n        console.error('Failed to generate configuration:', error);\n        alert(`Failed to generate configuration: ${error.message}`);\n        return null;\n    }\n};\n\n"],"mappings":"AAAA,OAAO,MAAMA,yBAAyB,GAAGA,CAACC,KAAK,EAAEC,KAAK,KAAK;EACvD,MAAMC,gBAAgB,GAAGF,KAAK,CACzBG,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACC,IAAI,KAAK,IAAI,CAAC,CAC5BC,GAAG,CAACC,MAAM,KAAK;IACZ,GAAGA,MAAM,CAACC,IAAI;IACdC,KAAK,EAAET,KAAK,CACPG,MAAM,CAACO,CAAC,IAAIA,CAAC,CAACL,IAAI,KAAK,MAAM,IAAIK,CAAC,CAACC,UAAU,KAAKJ,MAAM,CAACK,EAAE,CAAC,CAC5DN,GAAG,CAACO,QAAQ,KAAK;MACd,GAAGA,QAAQ,CAACL,IAAI;MAChBM,KAAK,EAAEd,KAAK,CACPG,MAAM,CAACY,CAAC,IAAIA,CAAC,CAACV,IAAI,KAAK,MAAM,IAAIU,CAAC,CAACJ,UAAU,KAAKE,QAAQ,CAACD,EAAE,CAAC,CAC9DN,GAAG,CAACU,QAAQ,KAAK;QAAC,GAAGA,QAAQ,CAACR,IAAI;QAAES,OAAO,EAAEC,QAAQ,CAACF,QAAQ,CAACR,IAAI,CAACS,OAAO,EAAE,EAAE;MAAC,CAAC,CAAC;IAC3F,CAAC,CAAC;EACV,CAAC,CAAC,CAAC;EAEP,MAAME,WAAW,GAAGlB,KAAK,CAACK,GAAG,CAACc,IAAI,IAAI;IAAA,IAAAC,UAAA,EAAAC,qBAAA,EAAAC,WAAA,EAAAC,WAAA;IAClC,MAAMC,cAAc,GAAGzB,KAAK,CAAC0B,IAAI,CAACtB,CAAC,IAAIA,CAAC,CAACQ,EAAE,KAAKQ,IAAI,CAACO,MAAM,CAAC;IAC5D,MAAMC,cAAc,GAAG5B,KAAK,CAAC0B,IAAI,CAACtB,CAAC,IAAIA,CAAC,CAACQ,EAAE,KAAKQ,IAAI,CAACS,MAAM,CAAC;IAE5D,IAAI,CAACJ,cAAc,IAAI,CAACG,cAAc,EAAE,OAAO,IAAI;IAEnD,MAAME,cAAc,GAAG9B,KAAK,CAAC0B,IAAI,CAACtB,CAAC,IAAIA,CAAC,CAACQ,EAAE,KAAKa,cAAc,CAACd,UAAU,CAAC;IAC1E,MAAMoB,cAAc,GAAG/B,KAAK,CAAC0B,IAAI,CAACtB,CAAC,IAAIA,CAAC,CAACQ,EAAE,KAAKgB,cAAc,CAACjB,UAAU,CAAC;IAE1E,IAAI,CAACmB,cAAc,IAAI,CAACC,cAAc,EAAE,OAAO,IAAI;IAEnD,MAAMC,YAAY,GAAGhC,KAAK,CAAC0B,IAAI,CAACtB,CAAC,IAAIA,CAAC,CAACQ,EAAE,KAAKkB,cAAc,CAACnB,UAAU,CAAC;IACxE,MAAMsB,YAAY,GAAGjC,KAAK,CAAC0B,IAAI,CAACtB,CAAC,IAAIA,CAAC,CAACQ,EAAE,KAAKmB,cAAc,CAACpB,UAAU,CAAC;IAExE,IAAI,CAACqB,YAAY,IAAI,CAACC,YAAY,EAAE,OAAO,IAAI;IAE/C,OAAO;MACHrB,EAAE,EAAEQ,IAAI,CAACR,EAAE;MACXe,MAAM,EAAE;QACJO,EAAE,EAAEF,YAAY,CAACpB,EAAE;QACnBuB,IAAI,EAAEL,cAAc,CAAClB,EAAE;QACvBwB,IAAI,EAAEX,cAAc,CAACb;MACzB,CAAC;MACDyB,WAAW,EAAE;QACTH,EAAE,EAAED,YAAY,CAACrB,EAAE;QACnBuB,IAAI,EAAEJ,cAAc,CAACnB,EAAE;QACvBwB,IAAI,EAAER,cAAc,CAAChB;MACzB,CAAC;MACD0B,WAAW,EAAE,EAAAjB,UAAA,GAAAD,IAAI,CAACZ,IAAI,cAAAa,UAAA,uBAATA,UAAA,CAAWiB,WAAW,KAAI,KAAK;MAC5CC,gBAAgB,GAAAjB,qBAAA,IAAAC,WAAA,GAAEH,IAAI,CAACZ,IAAI,cAAAe,WAAA,uBAATA,WAAA,CAAWgB,gBAAgB,cAAAjB,qBAAA,cAAAA,qBAAA,GAAI,IAAI;MACrDkB,KAAK,EAAE,EAAAhB,WAAA,GAAAJ,IAAI,CAACZ,IAAI,cAAAgB,WAAA,uBAATA,WAAA,CAAWgB,KAAK,KAAI;IAC/B,CAAC;EACL,CAAC,CAAC,CAACrC,MAAM,CAACO,CAAC,IAAIA,CAAC,KAAK,IAAI,CAAC;EAE1B,OAAO;IAAER,gBAAgB;IAAEiB;EAAY,CAAC;AAC5C,CAAC;AAED,OAAO,MAAMsB,qBAAqB,GAAG,MAAAA,CAAOzC,KAAK,EAAEC,KAAK,KAAK;EACzD,MAAMyC,OAAO,GAAG3C,yBAAyB,CAACC,KAAK,EAAEC,KAAK,CAAC;EAEvD,IAAI;IACA,MAAM0C,QAAQ,GAAG,MAAMC,KAAK,CAAC,sBAAsB,EAAE;MAAE;MACnDC,MAAM,EAAE,MAAM;MACdC,OAAO,EAAE;QACL,cAAc,EAAE;MACpB,CAAC;MACDC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAACP,OAAO;IAChC,CAAC,CAAC;IAEF,IAAI,CAACC,QAAQ,CAACO,EAAE,EAAE;MACd,MAAM,IAAIC,KAAK,CAAC,uBAAuBR,QAAQ,CAACS,MAAM,EAAE,CAAC;IAC7D;IAEA,MAAMC,MAAM,GAAG,MAAMV,QAAQ,CAACW,IAAI,CAAC,CAAC;IACpCC,OAAO,CAACC,GAAG,CAAC,uCAAuC,EAAEH,MAAM,CAAC;IAC5D,OAAOA,MAAM,CAACI,MAAM;EACxB,CAAC,CAAC,OAAOC,KAAK,EAAE;IACZH,OAAO,CAACG,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;IACzDC,KAAK,CAAC,qCAAqCD,KAAK,CAACE,OAAO,EAAE,CAAC;IAC3D,OAAO,IAAI;EACf;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}